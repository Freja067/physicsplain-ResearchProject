class i{constructor(i){this.id=i,this.rank=0,this.parent=this}}class t{constructor(){this.nodes=[]}findNode(t){if(void 0===this.nodes[t])return this.nodes[t]=new i(t),this.nodes[t];{let i=this.nodes[t];for(;i.id!==i.parent.id;)i=i.parent;return i}}find(i){return this.findNode(i).id}union(i,t){const s=this.findNode(i),n=this.findNode(t);s.id!==n.id&&(s.rank<n.rank?s.parent=n:s.rank>n.rank?n.parent=s:(n.parent=s,s.rank++))}}class s{constructor(i,t){this.x=i,this.y=t}set(i){return this.x=i.x,this.y=i.y,this}add(i){return this.x+=i.x,this.y+=i.y,this}scale(i){return this.x*=i,this.y*=i,this}normalize(){const i=this.length();return i>0&&1!==i&&this.scale(1/i),this}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}clear(){this.x=0,this.y=0}toString(){return this.x+", "+this.y}static cross(i,t,s,n){return i*n-t*s}static dot(i,t,s,n){return i*s+t*n}static length(i,t){return Math.sqrt(i*i+t*t)}static angle(i,t){let s=Math.atan2(t,i);return s<0&&(s+=2*Math.PI),s}}class n{constructor(i){this.restitution=i,this.collisionPoints=[]}merge(i){for(const t of i.collisionPoints)this.collisionPoints.push(t)}apply(){const i=this.collisionPoints.length,t=[],n=[];let e=0,o=0,r=Number.MAX_VALUE;do{o>0&&(r=o),o=0;for(let r=0;r<i;r++){const i=this.collisionPoints[r],h=i.collidingEntity.velocity,l=i.collidingEntity.angularVelocity,c=i.impactedEntity.velocity,a=i.impactedEntity.angularVelocity,d=i.collidingEntity.origin,y=i.contactPointX-d.x,u=i.contactPointY-d.y,g=i.impactedEntity.origin,m=i.contactPointX-g.x,x=i.contactPointY-g.y,v=i.getNormalMass();let p=-l*u,f=l*y;p-=-a*x,f-=a*m,p-=c.x,f-=c.y,p+=h.x,f+=h.y,0===e&&(t[r]=p*this.restitution,n[r]=f*this.restitution);let M=(s.dot(t[r],n[r],i.normalX,i.normalY)+s.dot(p,f,i.normalX,i.normalY))*v*-1;const w=i.accumulatedImpulse;i.accumulatedImpulse=Math.max(i.accumulatedImpulse+M,0),M=i.accumulatedImpulse-w,o+=Math.abs(M);const P=i.normalX*M,E=i.normalY*M,X=i.collidingEntity.invertedMass(),V=P*X,Y=E*X,A=i.collidingEntity.invertedInertia()*s.cross(y,u,P,E),B=i.impactedEntity.invertedMass();let I=P*B,N=E*B;I=-I,N=-N;const C=-i.impactedEntity.invertedInertia()*s.cross(m,x,P,E);i.addTempVelocities(V,Y,A,I,N,C)}for(let t=0;t<i;t++)this.collisionPoints[t].applyTempVelocities();e++}while(o>.001&&e<50&&o<=r)}static mergeCollisions(i){if(i.length<=1)return i;const s=new t;for(const t of i){const i=t.collisionPoints[0];s.union(i.collidingEntity.id,i.impactedEntity.id)}const n=[];for(const t of i){const i=t.collisionPoints[0],e=s.find(i.collidingEntity.id);void 0===n[e]?n[e]=t:n[e].merge(t)}const e=[];for(const i in n)e.push(n[i]);return e}}class e{constructor(i,t,n,e,o,r,h){this.collidingEntity=i,this.impactedEntity=t,this.normalX=n,this.normalY=e,this.contactPointX=o,this.contactPointY=r,this.separation=h,this.accumulatedImpulse=0,this.nv1=new s(0,0),this.nw1=0,this.nv2=new s(0,0),this.nw2=0}getNormalMass(){const i=this.collidingEntity.origin,t=i.x-this.contactPointX,n=i.y-this.contactPointY,e=this.impactedEntity.origin,o=e.x-this.contactPointX,r=e.y-this.contactPointY;let h=s.cross(t,n,this.normalX,this.normalY);h*=h;let l=s.cross(o,r,this.normalX,this.normalY);return l*=l,1/(this.collidingEntity.invertedMass()+this.impactedEntity.invertedMass()+h*this.collidingEntity.invertedInertia()+l*this.impactedEntity.invertedInertia())}addTempVelocities(i,t,s,n,e,o){this.nv1.x+=i,this.nv1.y+=t,this.nw1+=s,this.nv2.x+=n,this.nv2.y+=e,this.nw2+=o}applyTempVelocities(){this.collidingEntity.addVelocity(this.nv1),this.collidingEntity.addAngularVelocity(this.nw1),this.impactedEntity.addVelocity(this.nv2),this.impactedEntity.addAngularVelocity(this.nw2),this.nv1.clear(),this.nw1=0,this.nv2.clear(),this.nw2=0}}class o{constructor(i){this.id=i,this.origin=new s(0,0),this.angle=0,this.dimension=new s(.1,.1),this.mass=1,this.velocity=new s(0,0),this.angularVelocity=0,this.lateralFriction=1,this.rotationalFriction=1,this.force=new s(0,0),this.cornerX=[0,0,0,0],this.cornerY=[0,0,0,0]}finalize(){return this.inertia=(this.dimension.x*this.dimension.x+this.dimension.y*this.dimension.y)*this.mass/12,this.calculateCorners(),this}setOrigin(i,t){return this.origin.x=i,this.origin.y=t,this}setAngle(i){return this.angle=i,this}setDimension(i,t){return this.dimension.x=i,this.dimension.y=t,this}setMass(i){return this.mass=i,this}setForce(i,t){return this.force.x=i,this.force.y=t,this}advance(i){this.origin.x+=this.velocity.x*i,this.origin.y+=this.velocity.y*i,this.angle+=this.angularVelocity*i,this.angle>Math.Pi?this.angle-=2*Math.Pi:this.angle<-Math.Pi&&(this.angle+=2*Math.Pi),this.calculateCorners()}applyForces(i){this.velocity.x+=this.force.x*i*this.invertedMass(),this.velocity.y+=this.force.y*i*this.invertedMass(),this.velocity.scale(Math.max(0,1-i*this.lateralFriction)),this.angularVelocity*=Math.max(0,1-i*this.rotationalFriction)}calculateCorners(){const i=Math.sin(this.angle),t=Math.cos(this.angle),s=-i,n=t;this.cornerX[0]=this.origin.x+t*this.dimension.x*.5+s*this.dimension.y*.5,this.cornerY[0]=this.origin.y+i*this.dimension.x*.5+n*this.dimension.y*.5,this.cornerX[1]=this.origin.x-t*this.dimension.x*.5+s*this.dimension.y*.5,this.cornerY[1]=this.origin.y-i*this.dimension.x*.5+n*this.dimension.y*.5,this.cornerX[2]=this.origin.x-t*this.dimension.x*.5-s*this.dimension.y*.5,this.cornerY[2]=this.origin.y-i*this.dimension.x*.5-n*this.dimension.y*.5,this.cornerX[3]=this.origin.x+t*this.dimension.x*.5-s*this.dimension.y*.5,this.cornerY[3]=this.origin.y+i*this.dimension.x*.5-n*this.dimension.y*.5}invertedMass(){return this.isFixedBody()?0:1/this.mass}invertedInertia(){return this.isFixedBody()||0===this.inertia?0:1/this.inertia}isFixedBody(){return-1===this.mass}addVelocity(i){this.velocity.add(i)}addAngularVelocity(i){this.angularVelocity+=i}collide(i,t,s){const e=new n(s);return this.collideAllCorners(e,i,t),e.collisionPoints.length<2&&i.collideAllCorners(e,this,t),0===e.collisionPoints.length?null:e}collideAllCorners(i,t,s){for(let n=0;n<4;n++)this.collideSingleCorner(i,t,n,s)}collideSingleCorner(i,t,n,o){const r=1e-5,h=t.cornerX[n],l=t.cornerY[n];let c=h-this.origin.x,a=l-this.origin.y;const d=Math.cos(-this.angle),y=Math.sin(-this.angle),u=c*y+a*d;c=c*d-a*y,a=u;const g=.5*this.dimension.x,m=.5*this.dimension.y;if(c>=-g-r&&c<=g+r&&a>=-m-r&&a<=m+r){const n=t.velocity,r=t.angularVelocity,d=this.velocity,y=this.angularVelocity,u=h-t.origin.x,x=l-t.origin.y,v=h-this.origin.x,p=l-this.origin.y;let f=-r*x,M=r*u;f-=-y*p,M-=y*v,f-=d.x,M-=d.y,f+=n.x,M+=n.y;let w=f*o,P=M*o;const E=Math.cos(-this.angle),X=Math.sin(-this.angle),V=w*X+P*E;w=w*E-P*X,P=V;let Y,A,B=m-a,I=B,N=0,C=0;if(B<-P&&(N=1),B=g+c,B<w&&(N|=2),B<I&&(I=B,C=1),B=m+a,B<P&&(N|=4),B<I&&(I=B,C=2),B=g-c,B<-w&&(N|=8),B<I&&(I=B,C=3),N>0){let i=0;Y=0,A=0;for(let t=0;t<4;t++)if((N&1<<t)>0){const n=t,e=3===n?0:n+1;let o=this.cornerX[n]-this.cornerX[e],r=this.cornerY[n]-this.cornerY[e];const h=1/s.length(o,r);o*=h,r*=h;const l=o;o=-r,r=l,Y+=o,A+=r,i++}if(i>1){const i=s.length(Y,A);Y/=i,A/=i}}else{const i=C,t=3===i?0:i+1;let n=this.cornerX[i]-this.cornerX[t],e=this.cornerY[i]-this.cornerY[t];const o=1/s.length(n,e);n*=o,e*=o;const r=n;n=-e,e=r,Y=n,A=e}const F=new e(t,this,Y,A,h,l,I);i.collisionPoints.push(F)}}}class r{constructor(i,t,n,e,o,r){this.id=i,this.origin=t,this.velocity=new s(0,0),this.angularVelocity=0,this.radius=n,this.width=e,this.startAngle=o,this.endAngle=r}collide(i,t,o){let r=null;for(let t=0;t<4;t++){const h=i.cornerX[t],l=i.cornerY[t],c=h-this.origin.x,a=l-this.origin.y,d=s.length(c,a),y=s.angle(c,a);if(d>=this.radius&&d<this.radius+this.width&&y>this.startAngle&&y<this.endAngle){null===r&&(r=new n(o));const t=d-this.radius;let c=this.origin.x-h,a=this.origin.y-l;const y=s.length(c,a);c/=y,a/=y;const u=new e(i,this,c,a,h,l,t);r.collisionPoints.push(u)}}return r}invertedMass(){return 0}invertedInertia(){return 0}addVelocity(i){}addAngularVelocity(i){}}class h extends o{constructor(i){super(i),this.setMass(-1)}}class l{constructor(i,t,n){this.id=i,this.origin=t,this.radius=n,this.velocity=new s(0,0),this.angularVelocity=0}collide(i,t,o){let r=null,h=!1;for(let t=0;t<4;t++){const l=i.cornerX[t],c=i.cornerY[t],a=l-this.origin.x,d=c-this.origin.y,y=s.length(a,d);if(y<=this.radius){null===r&&(r=new n(o));const t=this.radius-y;let a=l-this.origin.x,d=c-this.origin.y;const u=s.length(a,d);a/=u,d/=u;const g=new e(i,this,a,d,l,c,t);r.collisionPoints.push(g),h=!0}}for(let t=0;t<4&&!h;t++){const s=t,l=3===t?0:t+1,c=i.cornerX[s],a=i.cornerY[s],d=i.cornerX[l],y=i.cornerY[l];let u=d-c,g=y-a;const m=1/Math.sqrt(u*u+g*g);u*=m,g*=m;const x=u;u=-g,g=x;const v=this.origin.x,p=this.origin.y;let f=u*this.radius,M=g*this.radius;f+=this.origin.x,M+=this.origin.y;let w=NaN,P=NaN;const E=d-c,X=v-f,V=y-a,Y=p-M,A=v-c,B=p-a;let I=E*Y-X*V;I=1/I;const N=I*(Y*A-X*B),C=I*(E*B-V*A);if(N>=0&&N<=1&&C>=0&&C<=1){w=(d-c)*N+c,P=(y-a)*N+a}if(!isNaN(w)){null==r&&(r=new n(o));const t=new e(i,this,u,g,w,P,0);r.collisionPoints.push(t),h=!0}}return r}invertedMass(){return 0}invertedInertia(){return 0}addVelocity(i){}addAngularVelocity(i){}}class c{constructor(){this.movableBodies=[],this.fixedBodies=[],this.start=0,this.previous=0,this.remainder=0,this.restitution=1}advance(i){0===this.start&&(this.start=i),0===this.previous&&(this.previous=i);let t=i-this.previous+this.remainder;for(;t>10;)this.advanceByTimestep(.01),t-=10;this.previous=i,this.remainder=t}advanceByTimestep(i){const t=this.collide(i);for(const t of this.movableBodies)t.applyForces(i);for(const i of t)i.apply();for(const t of this.movableBodies)t.advance(i)}collide(i){const t=[],s=this.movableBodies.length;for(let n=0;n<s-1;n++)for(let e=n+1;e<s;e++){const s=this.movableBodies[n].collide(this.movableBodies[e],i,this.restitution);null!==s&&t.push(s)}const e=this.fixedBodies.length;for(let n=0;n<s;n++)for(let s=0;s<e;s++){const e=this.fixedBodies[s].collide(this.movableBodies[n],i,this.restitution);null!==e&&t.push(e)}return n.mergeCollisions(t)}}export{o as Body,r as FixedArc,h as FixedBody,l as FixedCircle,c as State,s as Vector};
